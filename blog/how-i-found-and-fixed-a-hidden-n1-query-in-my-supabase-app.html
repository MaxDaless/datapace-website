<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BT0HRD8ZJ8"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-BT0HRD8ZJ8');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How I Found and Fixed a Hidden N+1 Query in My Supabase App (A Case Study) - Datapace Blog</title>
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon-16x16.png">
    <link rel="manifest" href="../assets/site.webmanifest">
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="blog.css">
</head>
<body>
    <nav>
        <div class="container">
            <div class="nav-content">
                <a href="../index.html" class="logo" aria-label="datapace.ai Homepage">
                    <img src="../assets/logo.png" alt="Datapace Wave Logo">
                    <span class="logo-text">datapace</span>
                </a>
                <div class="nav-links">
                    <a href="../index.html#features">Features</a>
                    <a href="../index.html#how-it-works">How It Works</a>
                    <a href="../index.html#pricing">Pricing</a>
                    <a href="../index.html#faq">FAQ</a>
                </div>
                <div class="nav-ctas">
                    <a href="https://app.datapace.ai" class="cta-button">Get Started</a>
                </div>
            </div>
        </div>
    </nav>

    <main class="article-main">
        <div class="article-content">
            <a href="../blog/" class="back-to-blog">‚Üê Back to Blog</a>
            
            <article class="article-header">
                <h1 class="article-title">How I Found and Fixed a Hidden N+1 Query in My Supabase App (A Case Study)</h1>
                <div class="article-meta">
                    <span class="blog-category">Case Study</span>
                    <span class="blog-read-time">8 min read</span>
                </div>
            </article>
            
            <div class="article-body">
                <p>My app felt slow.</p>

                <p>It wasn't one specific page; it was a general sluggishness, especially on pages displaying lists of data. The weird part? No single query was taking five seconds. It felt like a death by a thousand cuts, and I had no idea where to start looking.</p>

                <p>This is the story of how I diagnosed and fixed a classic <strong>N+1 query problem</strong>. It's a subtle but devastating performance bug that doesn't live in a single line of SQL, but in your application code. Here's the step-by-step process I used to find and fix it.</p>

                <blockquote>
                    <p><strong>TL;DR:</strong></p>
                    <ol>
                        <li><strong>Symptom:</strong> Used <code>pg_stat_statements</code> to discover a simple, fast query being called an enormous number of times‚Äîthe classic signature of an N+1 problem.</li>
                        <li><strong>Diagnosis:</strong> Traced the query back to a <code>map()</code> loop in my application code that was making a separate database call for each item in a list.</li>
                        <li><strong>Fix:</strong> Refactored the code to fetch all the data in a single round trip using either the Supabase client's nested selects or a more performant RPC function with a <code>JOIN</code>.</li>
                    </ol>
                </blockquote>

                <hr>

                <h2>Step 1: The Symptom - Finding the "Thousand Cuts" üïµÔ∏è</h2>

                <p>My first instinct led me to <code>pg_stat_statements</code>. I ran my favorite "Total Pain" query to see which queries were consuming the most database time <em>overall</em>.</p>

                <pre><code class="language-sql">SELECT
  (total_exec_time / 1000 / 60) as total_minutes,
  mean_exec_time as avg_ms,
  calls,
  query
FROM
  pg_stat_statements
ORDER BY
  total_exec_time DESC
LIMIT 5;</code></pre>

                <p>The result was shocking. The #1 query wasn't some complex analytics query. It was this:</p>

                <pre><code class="language-text">total_minutes   avg_ms   calls         query
--------------- -------- ------------- ----------------------------------------------------
15.4            0.85     1,087,058     SELECT "name" FROM "public"."users" WHERE "id" = $1</code></pre>

                <p>This was the clue. The query was incredibly fast on average (<strong>&lt;1 ms</strong>), but it had been called <strong>over a million times</strong>. This is the classic signature of an N+1 problem.</p>

                <hr>

                <h2>Step 2: The "Aha!" Moment - Finding the Loop in the Code</h2>

                <p>The database told me <em>what</em> was happening, but not <em>where</em>. I searched my application code for where I was fetching a user's name by their ID and found it buried in my code for rendering a list of blog posts.</p>

                <h4>The "Before" Code (The N+1 Mistake):</h4>

                <pre><code class="language-javascript">// 1. Fetch the list of the 50 most recent posts (The "1" Query)
const { data: posts, error } = await supabase
  .from('posts')
  .select('id, title, author_id')
  .limit(50);

// 2. Loop through the posts to get each author's name
const postsWithAuthors = await Promise.all(
  posts.map(async (post) => {
    // THIS RUNS 50 TIMES! (The "N" Queries)
    const { data: author } = await supabase
      .from('users')
      .select('name')
      .eq('id', post.author_id)
      .single();
    
    return { ...post, author_name: author.name };
  })
);</code></pre>

                <p>There it was. For a page with 50 posts, my code was making <strong>51 separate requests</strong> to the database. This cascade of network latency was the source of the sluggishness.</p>

                <hr>

                <h2>Step 3: The Fix - Getting Everything in a Single Trip</h2>

                <p>The fix is to get all the required information in a single query. Here are two ways to do it.</p>

                <h4>Option A: The Easy Fix (Supabase Client)</h4>

                <p>The Supabase client has a beautiful syntax for fetching related data. This is often the quickest and cleanest way to solve an N+1 problem.</p>

                <pre><code class="language-javascript">// The easy, client-side fix
const { data: postsWithAuthors, error } = await supabase
  .from('posts')
  .select(`
    id,
    title,
    users ( name )
  `)
  .limit(50);</code></pre>

                <h4>Option B: The Pro Fix (RPC Function)</h4>

                <p>For maximum performance on critical API endpoints, a dedicated database function (RPC) with a manual <code>JOIN</code> is unbeatable.</p>

                <p>First, create the function in the Supabase SQL Editor:</p>

                <pre><code class="language-sql">CREATE OR REPLACE FUNCTION get_posts_with_authors()
RETURNS TABLE (id int, title text, author_name text) AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.title, u.name as author_name
  FROM posts p
  JOIN users u ON p.author_id = u.id
  ORDER BY p.created_at DESC
  LIMIT 50;
END;
$$ LANGUAGE plpgsql;</code></pre>

                <p>Then, call it with a single line in your application code:</p>

                <pre><code class="language-javascript">// The most performant fix
const { data: postsWithAuthors, error } = await supabase
  .rpc('get_posts_with_authors');</code></pre>

                <p>The result was immediate. Page load time dropped from several seconds to <strong>under 200 milliseconds.</strong></p>

                <hr>

                <h2>The Challenge: Seeing Beyond the Database</h2>

                <p>This manual workflow works, but it's <strong>reactive and time-consuming</strong>. The database stats showed me the <em>symptom</em>, but finding the root cause required a manual hunt through my application code.</p>

                <p>This is exactly why <strong>Datapace</strong> is built to be more than just a database tool. Traditional performance platforms stop at the database layer. Datapace is designed to <strong>bridge the gap between your database and your application code.</strong></p>

                <p>Our platform not only flags the suspicious query pattern from <code>pg_stat_statements</code> but can also use application-level tracing to <strong>pinpoint the exact line of code</strong> generating the N+1 loop. Instead of a manual hunt, you get a direct alert:</p>

                <blockquote>
                    <p><em>"N+1 pattern detected in `api/posts.js`. The query fetching `users` is being called inside this `.map()` function."</em></p>
                </blockquote>

                <p>This turns a multi-hour investigation into a proactive, specific notification.</p>

                <hr>

                <h2>Conclusion: Performance is an Application-Level Problem</h2>

                <p>Sometimes, the biggest bottlenecks aren't in a single slow query, but in how your application code interacts with the database. A perfectly optimized query called in a loop can be more damaging than a complex query called once.</p>

                <p>Using <code>pg_stat_statements</code> to spot the symptom is a great skill, but a tool that automatically connects that symptom to the root cause in your code is what allows you to build and scale with confidence.</p>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <div class="footer-brand">
                <img src="../assets/logo.png" alt="Datapace Logo" class="footer-logo">
                <span class="footer-brand-text">Datapace</span>
            </div>
            <div class="footer-links">
                <div class="footer-col">
                    <h4>Product</h4>
                    <ul>
                        <li><a href="../index.html#features">Features</a></li>
                        <li><a href="../index.html#pricing">Pricing</a></li>
                    </ul>
                </div>
                <div class="footer-col">
                    <h4>About</h4>
                    <ul>
                        <li><a href="../blog/">Blog</a></li>
                        <li><a href="../careers.html">Careers</a></li>
                    </ul>
                </div>
                <div class="footer-col">
                    <h4>Get Started</h4>
                    <ul>
                        <li><a href="https://app.datapace.ai">Try Datapace</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </footer>
</body>
</html>